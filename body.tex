\newpage\likechapter{Тезаурус} %обозначение и сокращения
API - Интерфейс программирования приложений (иногда интерфейс прикладного программирования) (англ. application programming interface) — набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением (библиотекой, сервисом) для использования во внешних программных продуктах. 

MPI - Message Passing Interface (интерфейс передачи сообщений) — API для передачи информации, который позволяет обмениваться сообщениями между процессами, выполняющими одну задачу.

\chapter{Постановка задачи}
\section{Конкретизации требований и задачи}
Входными условиями вычисления (пользовательскими функциями) является определение:
\begin{itemize}
	\item функции  $ \phi $;
	\item функций $ u,g $;
	\item границ области.
\end{itemize}
Функции $\phi,u,g $ соответствуют функциям в уравнении:
$ (\Delta +c)^{p+1}u=-g, (\Delta+c)^{k}u|_{\Gamma}=\phi_{k} $
Функция границ области возвращает единицу если точка с некоторой погрешностью находится на границе. 
Входными данными является:
\begin{itemize}
	\item количество путей;
	\item начальная точка.
\end{itemize}

Для задания пользовательских функций мы можем использовать программный код, прессинг функций или скрип. Первый наиболее скор в разработки, но заставляет компилировать программу каждый раз когда мы меняем вычисляемое уравнение. Для борьбы с этим недостатком сделаем вычисление в классе, который вынесем в отдельный модуль. Получаемый модуль параллельного вычисления скомпилируем как статическую библиотеку. Определение пользовательских функций проходит как задания функций обратного вызова. Так-же сделаем шаблон программы для облегчения определения пользователем своих функций. В комплект необходимо вести реализацию под конкретные условия. 

С учетом того, что конечный программный продукт будет запускается как с изменением предыдущих параметров так и для частного конкретного случая ввод данных следует сделать с помощью аргументов и(или) файлов данных.

Вывод осуществляется на экран. 

Конкретизируем задачу: 
\begin{enumerate}
	\item Создание статической библиотеки класса с функциями обратного вызова.
	\item Создание приложение под конкретные условия.
	\item Создание файла данных под программу созданную по предыдущим условиям.
	\item Создание справки.
\end{enumerate}

Интерфейс программы смотреть приложение "Справка".

\section{Формулировка задачи}
Создать библиотеку параллельного вычисления вышеоговоренной задачи с удобным итерфейсом. Снабдить библиотеку примером и сопутствующей документациией(описание интерфейса и методов запуска).

В связи с прудностью заданания условий задачи скриптовыми методами и оринтировании на малый обьем и недилимость готовой программы, использовать функции обратного вызова.

Для быстрого изменения работы програмы без изменения ее структуры обеспечить выбор методов решения и алгоритмов распределения задач флагами.

Обеспечить отказаустойчивость и защищеность от дурака создание отдельного класса с необходиммым интерфейсом.
\section{Аналоги}
%\err{qwerty uiwe rty uio wer tyu ioe rt yui o}
Для режения данного класса задачь инженерами и математиками используются самописные программы последовательного и паралельного вычисления, а также скриптовые математические пакеты. Последние в силу своей структуры не позваляют решить задачу   методами представленными в данной дипломной работе.
Самописные программы же %не могут обеспечить приемлимый уровень оптимизации в наприсании кода ибо
требуют изучения языка хотя бы высогого уровня. Что заставляет людей изучать в принцепе не нужные им выщи на достаточном высоком уровне. Создание же библиотеки снижает этот уровень.

Главным аналогом на основе которого и разрабатывается приложение является программа Biharmon2. 
Все сравнительные тесты проводились именно с ней. Численные результаты полученные приложение являюся эталонными.
Алгоритм этой программы приведен в приложении. Недостатком данной реализации алгоритмов является:
\begin{itemize}
	\item необходимость изменять алгоритм и функции основной программы(малая степень защиты от дурака);
	\item последовательность вычислений;
	\item при изменении алгоритма вычисления меняется и часть программы.
\end{itemize}
\chapter{Методы решения и алгоритмы}
В работе расматриваются два метода решения(блуждание по сферам и блуждание по решетки) и два алгоритма распределения задачи(статический и динамический).
\section{Блуждание по сферам}
Рассмотрим задачу Дирихле для уравнения Гельмгольца
\begin{equation} \Delta u + cu = g,	 u|_{\Gamma} = \phi \end{equation}
в области $D \subset R^{n}$ с границей $\Gamma$ , причем $c < c^{*}$, где $c^{*}$ первое собственное число оператора Лапласа для области $D, r = (x1; : : : ; xn) \in D$. Предполагаются выполненными сформулированные условия регулярности функций g, ' и границы $\Gamma$, обеспечивающие существование и единственность решения задачи , а также его вероятностное представление и интегральное представление с помощью шаровой функции Грина.

Введем следующие обозначения:
\begin{itemize}
	\item $\bar{D}$  -- замыкание области $D$;
	\item $d(P)$ -- расстояние от точки $P$ до границы $\Gamma$;
	\item $\epsilon > 0 $ -- числовой параметр;
	\item $\Gamma_{\epsilon }$ -- $\epsilon$ -- окрестность границы $\Gamma$, т. е. $ \Gamma_{\epsilon }=\{ P \in \bar{D}:d(P) < \epsilon \} $;
	\item $S(P)$  максимальная из сфер (точнее - из гиперсфер) с центром в точке $P$, целиком лежащих в $\bar{D}, S(P) = \{Q \in \bar{D}: |Q - P| = d(P)\}$.
\end{itemize}

В процессе блуждания по сферам очередная точка $P_{k+1}$ выбирается равномерно по поверхности сферы $S(P_{k})$; процесс обрывается, если точка попадает в $ \Gamma_{\epsilon }$. Дадим точное определение процесса блуждания по сферам. Зададим цепь Маркова $\{R_{m}\}_{m=1,2,...,N} $ следующими характеристиками:\begin{itemize}
	\item $\pi (r) = \delta(r-r_{0})$ - плотность начального распределения (т.е. цепь выходит из точки $r_0$);
	\item $p(r,r') = \delta_{r}(r') $ плотность перехода из $r$ в $r'$, представляющая собой обобщенную плотность равномерного распределения вероятностейна сфере $S(r)$;
	\item $p_{0}(r)$ вероятность обрыва цепи, определяемая выражением \begin{equation} p_{0}(r)= 
	\left\{
\begin{aligned}
& 0, r \notin \Gamma_{\epsilon}\\ & 1, r\notin \Gamma_{\epsilon}
\end{aligned}
 \right. \end{equation}
\item{}$N$ - номер последнего состояния.
\end{itemize}
Как уже указывалось, данная цепь называется процессом блуждания по сферам. Ее можно, очевидно, записать в виде $r_{m} = r_{m-1} + \omega_{m}d(r_{m-1}); m = 1; 2;....;$
$\omega_{m}$ -- последовательность независимых изотропных векторов единич-
 длины.
\subsection{Оценки решения метагармонического уравнения$(\delta+c)^{p}u=g $}
Для случая $L=\delta, \lambda=0,c = const<c*$ вероятносное представление задачи имеет вид 
\begin{equation} u(r_{0})=E\int_{0}^{\gamma}e^{ct}g(\xi(t))dt+E[e^{c\tau}\Phi(\xi(\tau))],\end{equation}
где $\xi(t)$  начинающийся в точке $r_{0}$ соответствующий оператору Лапласа диффузионный процесс, $\tau $  момент первого выхода процесса из области D. На основе строго марковского свойства процесса отсюда имеем 
\begin{equation} u(r_{0})=\sum_{i=0}^{\infty} E [e^{c\tau_{i}} \int_{0}^{\tau_{i+1}-\tau_{i}}e^{ct}g(\xi(t+\tau_{i}))dt+E[\Phi(\xi(\tau)){}
\prod_{i=0}^{\infty}e^{c(\tau_{i+1}-\tau_{i})}],\end{equation}
где $ \tau_{i}$ - момент первого выхода процесса $\xi(t)$ на поверхность $i$-й сферы соответствующего блуждание по сферам.
\section{Алгоритмы распределения задачи}
В библиотеке используется два метода статический (равное распределение задачи при равных вычичлительных узлах) и динамический (предпологает разные вычислительные мощности отдельных узлов).

Статический метод распеделяет задачи в равных долях плюс процесс для не нулевого и вычет общего числа прощессов на нулевом. Это связано с общим сумированием результата на нулевом процессе.

Динамический распаралеливает половину задачи в равных долях между не нулевыми процессами(в дальнейшем -- считоводов). Нулевой процесс выполняет роль менеджера распределения задач (МРЗ). При окончаии расчетов первым считоводом МПЗ получает коэфициэнт производительности (КП) выраженный в секундах на проход. Этой велечене присваевается единичный статус и назад отправляется количество проходов равное первоначальным условиям, но от оставшегося числа. Если остается меньше необходимого минимума он отправляется полностью, а МРЗ переходит к сбору данных. При приходе последующих КП они сравневаются с единичным. Если он меньше, то текущей становится единичным. Назад отправляем \begin{equation} nWay = \frac{N}{2size\frac{Kp_{i}}{Kp_{1}}}, \end{equation} где Кр - коэфициэнт производительности, size - общие колличество прочессов. Если $nWay$ меньше необходимого минимума отправляется $N$ полностью, а МРЗ переходит к сбору данных.

\chapter{Выполнениие задачи}
\section{Используемые программые средства}
При создании требуемой библиотеки были использованы следующие программные средства и технологии.   

Message Passing Interface (MPI, интерфейс передачи сообщений) -- программный интерфейс (API)\footnote{см. сокращение} для передачи информации, который позволяет обмениваться сообщениями между процессами, выполняющими одну задачу. Разработан Уильямом Гроуппом, Эвином Ласком и другими.

MPI является наиболее распространённым стандартом интерфейса обмена данными в параллельном программировании. Существуют его реализации для большого числа компьютерных платформ. MPI используется при разработке программ для кластеров и суперкомпьютеров. Основным средством коммуникации между процессами в MPI является передача сообщений друг другу. Стандартизацией MPI занимается MPI Forum. В стандарте MPI описан интерфейс передачи сообщений, который должен поддерживаться как на платформе, так и в приложениях пользователя. В настоящее время существует большое количество бесплатных и коммерческих реализаций MPI. Существуют реализации для языков Фортран 77/90, Java, Си и Си++.

В первую очередь MPI ориентирован на системы с распределенной памятью, то есть когда затраты на передачу данных велики, в то время как OpenMP\footnote{http://openmp.org/wp/} ориентирован на системы с общей памятью (многоядерные с общим кэшем). Обе технологии могут использоваться совместно, дабы оптимально использовать в кластере многоядерные системы. Более подробно об этом \cite{mpi:offsite}.

При разработке прикладного кода использовалась распределённая система управления версиями файлов -- Git

Git — распределённая система управления версиями файлов. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день поддерживается Джунио Хамано.

Система управления версиями (от англ. Version Control System, VCS или Revision Control System) — программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

Такие системы наиболее широко используются при разработке программного обеспечения для хранения исходных кодов разрабатываемой программы. Однако они могут с успехом применяться и в других областях, в которых ведётся работа с большим количеством непрерывно изменяющихся электронных документов. В частности, системы управления версиями применяются в САПР, обычно в составе систем управления данными об изделии (PDM). Управление версиями используется в инструментах конфигурационного управления (Software Configuration Management Tools).
Программа является свободной и выпущена под лицензией GNU GPL 2.

Язык для написания приложения был выбран С++ как наиболее подходящий для разработки статической библиотеки.

Статическая библиотека в программировании — сборник подпрограмм или объектов, используемых для разработки программного обеспечения (ПО) выполненых в виде исходного текста, подключаемого программистом к своей программе на этапе написания, либо в виде объектных файлов, присоединяемых (линкуемых) к исполняемой программе на этапе компиляции. В результате программа включает в себя все необходимые функции, что делает её автономной, но увеличивает размер. Без статических библиотек объектных модулей (файлов) невозможно использование большинства современных компилирующих языков и систем программирования: Fortran, Pascal, C, C++ и других.

Статическая библиотека присоединяется во время компиляции програмы в то время как присоединение динамической происходит во время выполнения.

\chapter{Итоги работы}
\section{Численные результаты}
Расмотрим численные результаты для следующий задачи Дихиле:
\begin{equation} 
	\left\{
\begin{aligned}
& (\Delta + 2) (\Delta +8) u = 40e^{x}e^{y}\\ & (\Delta +8) u|_{\Gamma} = 10e^{x}e^{y}\\&u|_{\Gamma} = e^{x}e^{y}
\end{aligned}
 \right. \end{equation}
{}
в единичном квадрате. Решение данной задачи дано в \cite{luk:dis}.

\begin{table}[hp]
	\caption{Время выполнения и расхождения}
\begin{tabular}{|c|c|c|c|}
\hline 
Metot & N & $t_{cp}$ & $\Delta N$ \\ \hline
Par1 & 100003 & 1 sec & $+/- 200 $ \\ \hline
Par1 & 1000030 & 10 sec & $+/- 250 $ \\ \hline
Par2 & 100003 & 1 sec & $+/- 10 $ \\ \hline
Par2 & 1000030 & 12 sec & $+/- 10 $ \\ \hline
Pos & 100003 & 2 sec & -- \\ \hline
Pos & 1000030 & 25 sec & -- \\ \hline
\end{tabular}
\end{table}

В таблице представленны результаты производительности, оценки точности и численные результаты совпадают для всех методов. Используются следующие сокращения для таблицы: Por - результаты получены в аналоге, Par1 - статичный метод расчета, Par2 - динамичный метод расчета.
\chapter{Руководство пользователя}
\section{Установка}
Для сборки приложеия под Windows необходимо MPICH2, набор унтилит для компиляции: компилятор GNU GCC и GNU Make данные унтилиты представленны в пакете MinGW. Для Linux GNU GCC не обязателен, компиляция происходит силами пакета MPICH2.
\begin{enumerate}
	\item Скачайте необходимую версию библиотеки с тестовым примером.
	\item Запустите консоль в папке проэкта или перейдите в нее с помощью команды cd.
	\begin{itemize}
		\item нажмите Пуск -> Выполнить -> cmd - Это откроет консоль Windows;
		\item в консоли наберите имя диска на котором распологается проэкт с двоиточеем на конце (C:);
		\item там же напечатайте cd <путь к проэкту > (cd C:\\project).
	\end{itemize}
	\item Запустите make.
\end{enumerate}
Результатом станет скомпилированный тестовый пример и статическая библиотека находящиеся в папке с проэктом.

\section{Запуск приложения}
Для запуска приложения набрать в консоли:\\
linux\\
	mpirun -n <Кол. процессов> <Имя программы> [опции]\\
windows\\
	mpiexec -n <Кол. процессов> <Имя программы> [опции]\\
Опции\\
-n<Кол.Путей> - Задает количество путей\\
-f  - Печать в файл\\
\\
Пример:\\
	mpirun -n 100 ./main -n3000 -f\\
\newpage\likechapter{Заключение}
 Сформируем основные результаты работы:
 \begin{enumerate}
	\item Создана статической библиотеки класса с функциями обратного вызова.
	\item .
	\item Создана приложение под конкретные условия.
	\item Оценино оптимизация для двух алгоритмов и двух методов решения.
\end{enumerate}
