\chapter{Постановка задачи}
\section{Конкретизации требований и задачи}
Входными условиями вычисления (пользовательскими функциями) является определение:
\begin{itemize}
	\item функции  $ \phi $;
	\item функций $ u,g $;
	\item границ области.
\end{itemize}
Функции $\phi,u,g $ соответствуют функциям в уравнении:
$ (\Delta +c)^{p+1}u=-g, (\Delta+c)^{k}u|_{\Gamma}=\phi_{k} $
Функция границ области возвращает единицу если точка с некоторой погрешностью находится на границе. 
Входными данными является:
\begin{itemize}
	\item количество путей;
	\item начальная точка.
\end{itemize}

Для задания пользовательских функций мы можем использовать программный код, прессинг функций или скрип. Первый наиболее скор в разработки, но заставляет компилировать программу каждый раз когда мы меняем вычисляемое уравнение. Для борьбы с этим недостатком сделаем вычисление в классе, который вынесем в отдельный модуль. Получаемый модуль параллельного вычисления скомпилируем как статическую библиотеку. Определение пользовательских функций проходит как задания функций обратного вызова. Так-же сделаем шаблон программы для облегчения определения пользователем своих функций. В комплект необходимо вести реализацию под конкретные условия. 

С учетом того, что конечный программный продукт будет запускается как с изменением предыдущих параметров так и для частного конкретного случая ввод данных следует сделать с помощью аргументов и(или) файлов данных.

Вывод осуществляется на экран. 

Конкретизируем задачу: 
\begin{enumerate}
	\item Создание статической библиотеки класса с функциями обратного вызова.
	\item Создание приложение под конкретные условия.
	\item Создание файла данных под программу созданную по предыдущим условиям.
	\item Создание справки.
\end{enumerate}

Интерфейс программы смотреть приложение "Справка".

\section{Формулировка задачи}
Создать библиотеку параллельного вычисления выше оговоренной задачи с удобным интерфейсом. Снабдить библиотеку примером и сопутствующей документацией(описание интерфейса и методов запуска).

В связи с трудностью задания условий задачи скриптовыми методами и ориентирование на малый объем и неделимость готовой программы, использовать функции обратного вызова.

Для быстрого изменения работы программы без изменения ее структуры обеспечить выбор методов решения и алгоритмов распределения задач флагами.

Обеспечить отказоустойчивость и защищенность от дурака создание отдельного класса с необходимым интерфейсом.
\section{Аналоги}
%\err{qwerty uiwe rty uio wer tyu ioe rt yui o}
Для решения данного класса задач инженерами и математиками используются самописные программы последовательного и параллельного вычисления, а также скриптовые математические пакеты. Последние в силу своей структуры не позволяют решить задачу методами представленными в данной дипломной работе.
Самописные программы же %не могут обеспечить приемлимый уровень оптимизации в наприсании кода ибо
требуют изучения языка хотя бы высокого уровня. Что заставляет людей изучать в принципе не нужные им вещи на достаточном высоком уровне. Создание же библиотеки снижает этот уровень.

Главным аналогом на основе которого и разрабатывается приложение является программа Biharmon2. 
Все сравнительные тесты проводились именно с ней. Численные результаты полученные приложение являющийся эталонными.
Алгоритм этой программы приведен в приложении. Недостатком данной реализации алгоритмов является:
\begin{itemize}
	\item необходимость изменять алгоритм и функции основной программы(малая степень защиты от дурака);
	\item последовательность вычислений;
	\item при изменении алгоритма вычисления меняется и часть программы.
\end{itemize}
\chapter{Методы решения и алгоритмы}
В работе рассматриваются два метода решения(блуждание по сферам и блуждание по решетки) и два алгоритма распределения задачи(статический и динамический).
\section{Блуждание по решетке}
В вычислительной математике для нахождения приближенного решения классическим подходом является замена дифференциальных уравнений соответствующей разностной задачей. Полученную систему линейных уравнений возможно решить методом Монте-Карло, используя случайные "блуждания по решетке", после приведения ее к специ-
альному виду:
\begin{equation}
	u = Ау + f, p(А) < 1,
\end{equation}
где $p(А)$  спектральный радиус матрицы А. Воспользуемся данным подходом применительно к рассматриваемым ниже задачам.

В этой главе допускается, что функции $c, g, \phi и u$ могут быть комплексными, причем $М = Re(c)$.

В области $D$ строится равномерная сетка с шагом $h$ и в качестве
оценки решения задачи для $L = \Delta $ в узлах сетки $r=(i_{1}h,\dots,\i_{n}h) $рассматривается решение разностной задачи:
\begin{equation} 
	\left\{
\begin{aligned}
& (\Delta_{h}+c^{h}+\lambda)u^{h}=-g^{h}\\ & u^{h}|_{\Gamma_{h}}=\phi^{h}.
\end{aligned}
 \right. 
 \label{qw1}
 \end{equation}
 
Здесь $∆_{h} $ -- стандартный разностный оператор Лапласа; $D_{h}$ -- сеточная область (множество внутренних узлов); $Γ_{h}$  сеточная граница; $u^{h}$ --  сеточная функция, определенная на $D_{h} \cup \Gamma_{h}$ ;$g^{h},c^{h},M^{h},\phi^{h}$ -- значения соответствующих функций в узлах сетки. Для простоты изложения здесь
рассматривается вариант, когда все граничные узлы сетки лежат на исходной границе $Γ$, то есть область $D_{h}$ является объединением "координатных" параллелепипедов.

Свойства разностной аппроксимации оператора Лапласа позволяют
предположить, что при достаточно малых $h$ все собственные значения
оператора $∆_{h}$ для области $D_{h}$ отрицательны. Обозначим через -- $c^{*}_{h}$ то из них, которое имеет наименьшую абсолютную величину. Тогда для $ M^{h}+\lambda_{0} < c^{*}_{h} $
задача имеет единственное решение.

Уравнение \ref{qw1} можно представить в виде:
\begin{equation}
u^{h}_{i}=s_{i}\sum^{L}_{j=1}{p_{ij}u^{h}_{j}+f^{h}_{i}}
	\label{qw2}
\end{equation} 
где $i; j = (1; \dots; L)$ --  номера узлов сетки, причем $p_{ij} = 1/(2n)$, если i 
номер внутреннего узла, а j  соседнего с ним; $p_{ij} = 0$ для граничных
узлов. Для граничных узлов полагаем $s_{i} = 0$; для остальных узлов
\begin{equation}
s_{i}= 
	\left[
1-\frac{(c^{h}_{i}+\lambda)h^{2}}{2n}
 \right]^{-1} 
	\label{qw3}
\end{equation}
Свободный элемент $f^{h}$ определяется соотношениями:
\begin{equation} f^{h}_{i}= 
	\left\{
\begin{aligned}
& \frac{h^{2}}{2n}s_{i}g^{h}_{i}, r_{i} \in D_{h}\\ & \phi^{h}_{i}, r_{i} \in \Gamma_{h}
\end{aligned}
 \right. \label{qw4}\end{equation}
\subsection{Оценка решения уравнения (∆ + c)(∆ + b)u = Ўg}
Рассмотрим следующую задачу Дирихле для бигармонического урав-
нения: 8
> > > <
> > > :
(4 + c)(4 + b)u = Ўg;
4u + bu
Ї
Ї
Ї
Γ = ';
u
Ї
Ї
Ї
Γ = Г;
(2:11)
и эквивалентную ей систему уравнений
8
> > > > > <
> > > > > :
4u + bu = v;
u
Ї
Ї
Ї
Γ = Г;
4v + cv = Ўg;
v
Ї
Ї
Ї
Γ = '
(2:12)
в области D 2 Rn с границей Γ, которая предполагается односвязной и
кусочно гладкой, причјм где Ўc  первое собственное значение оператора Лапласа для области
D, произвольная точка r = (x1; : : : ; xn) 2 D. Будем полагать также что
функции c, b, и g удовлетворяют условию Гјльдера в Ї D, а функции '; Г
непрерывны на границе Г. Условия регулярности, обеспечивающие су
ществование и единственность решения данной задачи, предполагаются
выполненными в том числе и после замены всех параметрических функ
ций их модулями.
В области D строится равномерная сетка с шагом h и в качеств
оценки решения исходной задачи в узлах сетки r = (i1h; : : : ; inh) рас
сматривается решение разностной задачи:
8
<
:
4huh + bhuh = vh в Dh;
uh
Ї
Ї
Ї
Γh
= Гh;
(2:13
8
<
:
4hvh + chvh = Ўgh в Dh;
vh
Ї
Ї
Ї
Γh
= 'h;
(2:14
где vh  сеточная функция, определенная на Dh [ Γh; bh, Гh  значе
ния функций b(r), Г(r) в узлах сетки. Остальные обозначения и условия
примем такими же как в п. 2.1. Тогда для Mh < c¤
h задача (2.13) и (2.14
имеет единственное решение.
Соотношения (2.13), (2.14) перепишем в виде
uh
i1;i2;:::;in =
uh
i1Ў1;i2;:::;in + ў ў ў + uh
i1;i2;:::;in+1
2n(1 Ў bh
i1;i2;:::;inh2
2n )
Ў
vh
i1;i2;:::;inh2
2n Ў bh
i1;i2;:::;inh2
:
vh
i1;i2;:::;in =
vh
i1Ў1;i2;:::;in + ў ў ў + vh
i1;i2;:::;in+1
2n(1 Ў ch
i1;i2;:::;inh2
2n )
+
gh
i1;i2;:::;inh2
2n Ў ch
i1;i2;:::;inh2
:
Более удобной для целей работы является следующая форма записи:
где и; й = (1; : : : ; Л)  номера узлов сетки, причем пий = 1=(2н), если и 
номер внутреннего узла, а й  соседнего с ним; пий = 0 для граничных
узлов. Для граничных узлов полагаем qи = си = 0; для остальных узлов
qи = [1 Ў ч
и х2=(2н)]
Ў1
си = [1 Ў бх
и х2=(2н)]
Ў1
:
Свободные элементы фх и � фх определяются соотношениями:
фх
и =
( х2
2нqигх
и ; ри 2 Дх
ьх
и ; ри 2 Γх
; � фх
и =
(
Ўх2
2нсивх
и ; ри 2 Дх
Гх
и ; ри 2 Γх
:
Теорема 5. В условиях задачи (2.11) при Мх < ц¤
х верно равенство
ух
и0 = Е»и0, где
»и0 = Ўх2
2н
Н Х
й=0
фх
ий
й Х
л=0
(
л Ы
к=0
сик)(
йЎ1 Ы
к=л
qик) + (
НЎ1 Ы
к=0
сик)Гх
иН ;
йЎ1 Ы
к=й
=
(
1; й < Н
0; й = Н
(2:17)
Здесь и0; : : : ; ин  номера узлов случайной цепи Маркова с начальным
распределением ±и0 и вероятностями перехода пий , Н  случайный номер
первого попадания на границу сеточной области.
\section{Блуждание по сферам}
Рассмотрим задачу Дирихле для уравнения Гельмгольца
\begin{equation} \Delta u + cu = g,	 u|_{\Gamma} = \phi \end{equation}
в области $D \subset R^{n}$ с границей $\Gamma$ , причем $c < c^{*}$, где $c^{*}$ первое собственное число оператора Лапласа для области $D, r = (x1;\dots; xn) \in D$. Предполагаются выполненными сформулированные условия регулярности функций g, ' и границы $\Gamma$, обеспечивающие существование и единственность решения задачи , а также его вероятностное представление и интегральное представление с помощью шаровой функции Грина.

Введем следующие обозначения:
\begin{itemize}
	\item $\bar{D}$  -- замыкание области $D$;
	\item $d(P)$ -- расстояние от точки $P$ до границы $\Gamma$;
	\item $\epsilon > 0 $ -- числовой параметр;
	\item $\Gamma_{\epsilon }$ -- $\epsilon$ -- окрестность границы $\Gamma$, т. е. $ \Gamma_{\epsilon }=\{ P \in \bar{D}:d(P) < \epsilon \} $;
	\item $S(P)$  максимальная из сфер (точнее - из гиперсфер) с центром в точке $P$, целиком лежащих в $\bar{D}, S(P) = \{Q \in \bar{D}: |Q - P| = d(P)\}$.
\end{itemize}

В процессе блуждания по сферам очередная точка $P_{k+1}$ выбирается равномерно по поверхности сферы $S(P_{k})$; процесс обрывается, если точка попадает в $ \Gamma_{\epsilon }$. Дадим точное определение процесса блуждания по сферам. Зададим цепь Маркова $\{R_{m}\}_{m=1,2,\dots,N} $ следующими характеристиками:\begin{itemize}
	\item $\pi (r) = \delta(r-r_{0})$ - плотность начального распределения (т.е. цепь выходит из точки $r_0$);
	\item $p(r,r') = \delta_{r}(r') $ плотность перехода из $r$ в $r'$, представляющая собой обобщенную плотность равномерного распределения вероятностей на сфере $S(r)$;
	\item $p_{0}(r)$ вероятность обрыва цепи, определяемая выражением \begin{equation} p_{0}(r)= 
	\left\{
\begin{aligned}
& 0, r \notin \Gamma_{\epsilon}\\ & 1, r\notin \Gamma_{\epsilon}
\end{aligned}
 \right. \end{equation}
\item{}$N$ - номер последнего состояния.
\end{itemize}
Как уже указывалось, данная цепь называется процессом блуждания по сферам. Ее можно, очевидно, записать в виде $r_{m} = r_{m-1} + \omega_{m}d(r_{m-1}); m = 1; 2;....;$
$\omega_{m}$ -- последовательность независимых изотропных векторов единичной
 длины.
\subsection{Оценки решения метагармонического уравнения$(\delta+c)^{p}u=g $}
Для случая $L=\delta, \lambda=0,c = const<c*$ вероятностное представление задачи имеет вид 
\begin{equation} u(r_{0})=E\int_{0}^{\gamma}e^{ct}g(\xi(t))dt+E[e^{c\tau}\Phi(\xi(\tau))],\end{equation}
где $\xi(t)$  начинающийся в точке $r_{0}$ соответствующий оператору Лапласа диффузионный процесс, $\tau $  момент первого выхода процесса из области D. На основе строго марковского свойства процесса отсюда имеем 
\begin{equation} u(r_{0})=\sum_{i=0}^{\infty} E [e^{c\tau_{i}} \int_{0}^{\tau_{i+1}-\tau_{i}}e^{ct}g(\xi(t+\tau_{i}))dt+E[\Phi(\xi(\tau)){}
\prod_{i=0}^{\infty}e^{c(\tau_{i+1}-\tau_{i})}],\end{equation}
где $ \tau_{i}$ - момент первого выхода процесса $\xi(t)$ на поверхность $i$-й сферы соответствующего блуждание по сферам.
\section{Алгоритмы распределения задачи}
В библиотеке используется два метода статический (равное распределение задачи при равных вычислительных узлах) и динамический (предполагает разные вычислительные мощности отдельных узлов).

Статический метод распределяет задачи в равных долях плюс процесс для не нулевого и вычет общего числа процессов на нулевом. Это связано с общим суммированием результата на нулевом процессе.

Динамический распределяет половину задачи в равных долях между не нулевыми процессами(в дальнейшем -- вычислители). Нулевой процесс выполняет роль менеджера распределения задач (МРЗ). При окончании расчетов первым вычислителем МПЗ получает коэффициент производительности (КП) выраженный в секундах на проход. Этой величине присваивается единичный статус и назад отправляется количество проходов равное первоначальным условиям, но от оставшегося числа. Если остается меньше необходимого минимума он отправляется полностью, а МРЗ переходит к сбору данных. При приходе последующих КП они сравниваются с единичным. Если он меньше, то текущей становится единичным. Назад отправляем \begin{equation} nWay = \frac{N}{2aP\frac{Kp_{i}}{Kp_{1}}}, \end{equation} где Кр - коэффициент производительности, $size$ - общие количество процессов, $aP=size-1$. Если $nWay$ меньше необходимого минимума отправляется $N$ полностью, а МРЗ переходит к сбору данных. В графическом представленнии алгоритм можно просмотреть на рисунке \ref{staticAndDinamic}

\begin{figure}
\begin{small}
\input{staticAndDinamic}
\end{small}
\caption{Динамический алгоритм}
\label{staticAndDinamic}
\end{figure}

\chapter{Выполнение задачи}
\section{Используемые программные средства}
При создании требуемой библиотеки были использованы следующие программные средства и технологии.   

Message Passing Interface (MPI, интерфейс передачи сообщений) -- программный интерфейс (API)\footnote{Application programming interface} для передачи информации, который позволяет обмениваться сообщениями между процессами, выполняющими одну задачу. Разработан Уильямом Гроуппом, Эвином Ласком и другими.

MPI является наиболее распространённым стандартом интерфейса обмена данными в параллельном программировании. Существуют его реализации для большого числа компьютерных платформ. MPI используется при разработке программ для кластеров и суперкомпьютеров. Основным средством коммуникации между процессами в MPI является передача сообщений друг другу. Стандартизацией MPI занимается MPI Forum. В стандарте MPI описан интерфейс передачи сообщений, который должен поддерживаться как на платформе, так и в приложениях пользователя. В настоящее время существует большое количество бесплатных и коммерческих реализаций MPI. Существуют реализации для языков Фортран 77/90, Java, Си и Си++.

В первую очередь MPI ориентирован на системы с распределенной памятью, то есть когда затраты на передачу данных велики, в то время как OpenMP\footnote{http://openmp.org/wp/} ориентирован на системы с общей памятью (многоядерные с общим кэшем). Обе технологии могут использоваться совместно, дабы оптимально использовать в кластере многоядерные системы. Более подробно об этом \cite{mpi:offsite}.

При разработке прикладного кода использовалась распределённая система управления версиями файлов -- Git

Git — распределённая система управления версиями файлов. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день поддерживается Джунио Хамано.

Система управления версиями (от англ. Version Control System, VCS или Revision Control System) — программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

Такие системы наиболее широко используются при разработке программного обеспечения для хранения исходных кодов разрабатываемой программы. Однако они могут с успехом применяться и в других областях, в которых ведётся работа с большим количеством непрерывно изменяющихся электронных документов. В частности, системы управления версиями применяются в САПР, обычно в составе систем управления данными об изделии (PDM). Управление версиями используется в инструментах конфигурационного управления (Software Configuration Management Tools).
Программа является свободной и выпущена под лицензией GNU GPL 2.

Язык для написания приложения был выбран С++ как наиболее подходящий для разработки статической библиотеки.

Статическая библиотека в программировании -- сборник подпрограмм или объектов, используемых для разработки программного обеспечения (ПО) выполненных в виде исходного текста, подключаемого программистом к своей программе на этапе написания, либо в виде объектных файлов, подклучающихся к исполняемой программе на этапе компиляции. В результате программа включает в себя все необходимые функции, что делает её автономной, но увеличивает размер. Без статических библиотек объектных модулей (файлов) невозможно использование большинства современных компилирующих языков и систем программирования: Fortran, Pascal, C, C++ и других.

Статическая библиотека присоединяется во время компиляции программы в то время как присоединение динамической происходит во время выполнения.

\chapter{Итоги работы}
Библиотека содержит один класс, полность реализующий функционал дипломной работы.  
\section{Схема приложенния}
\begin{spacing}{0.9}
\lstinputlisting[language=C++, firstline=0,basicstyle=\small]{../gcc-con-mpi-diplom/reshotka.hpp}
\end{spacing}

\section{Численные результаты}
Рассмотрим численные результаты для следующий задачи Дихиле:
\begin{equation} 
	\left\{
\begin{aligned}
& (\Delta + 2) (\Delta +8) u = 40e^{x}e^{y}\\ & (\Delta +8) u|_{\Gamma} = 10e^{x}e^{y}\\&u|_{\Gamma} = e^{x}e^{y}
\end{aligned}
 \right. \end{equation}
{}
в единичном квадрате. Решение данной задачи дано в \cite{luk:dis}.

\begin{table}[hp]
	\caption{Время выполнения и расхождения}
	\label{sample_table}
\begin{tabular}{|c|c|c|c|}
\hline 
Metot & N & $t_{cp}$ & $\Delta$ проходов \\ \hline
Par1 & 100003 & 0.6 sec & $+/- 200 $ \\ \hline
Par1 & 1000030 & 6 sec & $+/- 250 $ \\ \hline
Par2 & 100003 & 1 sec & $+/- 10 $ \\ \hline
Par2 & 1000030 & 12 sec & $+/- 10 $ \\ \hline
Pos & 100003 & 2 sec & -- \\ \hline
Pos & 1000030 & 25 sec & -- \\ \hline
\end{tabular}
\end{table}

В таблице \ref{sample_table} представлены результаты производительности, оценки точности и численные результаты совпадают для всех методов. Используются следующие сокращения для таблицы: Por - результаты получены в аналоге, Par1 - статичный метод расчета, Par2 - динамичный метод расчета.
\chapter{Руководство пользователя}
\section{Установка}
Для сборки приложения под Windows необходимо MPICH2, набор утилит для компиляции: компилятор GNU GCC и GNU Make данные утилиты представлены в пакете MinGW. Для Linux GNU GCC не обязателен, компиляция происходит силами пакета MPICH2.
\begin{enumerate}
	\item Скачайте необходимую версию библиотеки с тестовым примером.
	\item Запустите консоль в папке проекта или перейдите в нее с помощью команды cd.
	\begin{itemize}
		\item нажмите Пуск -> Выполнить -> cmd - Это откроет консоль Windows;
		\item в консоли наберите имя диска на котором располагается проект с двоеточием на конце (C:);
		\item там же напечатайте cd <путь к проэкту > (cd C:\\project).
	\end{itemize}
	\item Запустите make.
\end{enumerate}
Результатом станет скомпилированный тестовый пример и статическая библиотека находящиеся в папке с проэктом.

\section{Запуск приложения}
Для запуска приложения набрать в консоли:\\
linux\\
	mpirun -n <Кол. процессов> <Имя программы> [опции]\\
windows\\
	mpiexec -n <Кол. процессов> <Имя программы> [опции]\\
Опции\\
-n<Кол.Путей> - Задает количество путей\\
-f  - Печать в файл\\
\\
Пример:\\
	mpirun -n 100 ./main -n3000 -f\\
\newpage\likechapter{Заключение}
 Сформируем основные результаты работы:
 \begin{enumerate}
	\item Создана статической библиотеки класса с функциями обратного вызова.
	\item .
	\item Создана приложение под конкретные условия.
	\item Оценено оптимизация для двух алгоритмов и двух методов решения.
\end{enumerate}
