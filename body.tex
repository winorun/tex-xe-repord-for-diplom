\chapter{Постановка задачи}
\section{Конкретизации требований и задачи}
Основная задача дипломной работы -- написание библиотеки для вычисления бигармонического уравнения $$ (\Delta +c)^{2}u=-g, (\Delta+c)^{k}u|_{\Gamma}=\phi_{k}, $$входными параметрами которой являются:
\begin{itemize}
	\item граничные функции;
	\item правая часть уравнения;
	\item точка в которой вычисляется решение;
	\item количество траекторий;
	\item правая часть уравнения;
	\item функция границ области.
\end{itemize}
Функция границ области возвращает единицу если точка с некоторой погрешностью находится на границе. 

Рассмотрим возможные пути задания функциональных параметров.
\begin{itemize}
	\item Использование функций обратного вызова;
	\item парсинг функций;
	\item скрипт.
\end{itemize}
Первый наиболее скор в разработки, но заставляет компилировать программу каждый раз когда мы меняем вычисляемое уравнение. Неприемлемым недостатком второго и третьего является чрезмерное увеличении исполняемой программы. В связи с этим в дипломной работе использовался первый вариант.Для уменьшения времени компиляции и облечении разработки готового приложения функционал вынесен в отдельную библиотеку. 

Вывод осуществляется на экран и возвращается значениями из функций. 

Конкретизируем задачу: 
\begin{enumerate}
	\item Создание статической библиотеки класса для вычисления бигармонического уравнения.
	\item Создание примера приложение.
	\item Возврат значений дисперсии и решения уравнения.
	\item Печать на экран с разными форматами.
	\item Создание справки.
\end{enumerate}
\section{Формулировка задачи}
Создать библиотеку параллельного вычисления выше оговоренной задачи с удобным интерфейсом. Снабдить библиотеку примером и сопутствующей документацией(описание интерфейса и методов запуска).

В связи с трудностью задания условий задачи скриптовыми методами и ориентирование на малый объем и неделимость готовой программы, использовать функции обратного вызова.

Для быстрого изменения работы программы без изменения ее структуры обеспечить выбор методов решения и алгоритмов распределения задач флагами.

Обеспечить отказоустойчивость.
\section{Аналоги}
%\err{qwerty uiwe rty uio wer tyu ioe rt yui o}
Для решения данного класса задач инженерами и математиками используются самописные программы последовательного и параллельного вычисления, а также математические пакеты такие как MatLab, Matematica, Wolfram Alfa. В этих пакетах отсутствует данные методы решения.

Самописные программы требуют дополнительных ресурсов, при этом возможны проблемы связанные с тестированием, поддержкой, оптимизацией требуемых решений.
Создание библиотеки снижает этот уровень этих проблем.

Главным аналогом на основе которого и разрабатывается приложение является последовательная программа Biharmon2. 
Все сравнительные тесты проводились именно с ней. Численные результаты полученные приложение являющийся эталонными.
Схема работы алгоритма показана на рисунке А.1 приложения А. Первый прямоугольник представляет собой вычисление в точке, второй же полный проход по траектории до границы. Недостатком данной реализации алгоритмов является:
\begin{itemize}
	\item необходимость изменять алгоритм и функции основной программы(малая степень защиты от дурака);
	\item последовательность вычислений;
	\item при изменении алгоритма вычисления меняется и часть программы.
\end{itemize}
\chapter{Методы решения и алгоритмы}
В работе рассматриваются два метода решения(блуждание по сферам и блуждание по решетки) и два алгоритма распределения траекторий(статический и динамический).
\section{Блуждание по решетке}
\label{Bl}
В вычислительной математике для нахождения приближенного решения классическим подходом является замена дифференциальных уравнений соответствующей разностной задачей. Полученную систему линейных уравнений возможно решить методом Монте-Карло, используя случайные "блуждания по решетке", после приведения ее к специальному виду:
\begin{equation}
	u = Au + f, p(A) < 1,
\end{equation}
где $p(A)$  спектральный радиус матрицы А. Воспользуемся данным подходом применительно к рассматриваемым ниже задачам.

В этой главе допускается, что функции $c, g, \phi, u$ могут быть комплексными, причем $М = Re(c)$.

В области $D$ строится равномерная сетка с шагом $h$ и в качестве
оценки решения задачи для $L = \Delta $ в узлах сетки $r=(i_{1}h,\dots,\i_{n}h) $рассматривается решение разностной задачи:
\begin{equation} 
	\left\{
\begin{aligned}
& (\Delta_{h}+c^{h}+\lambda)u^{h}=-g^{h}\\ & u^{h}|_{\Gamma_{h}}=\phi^{h}.
\end{aligned}
 \right. 
 \label{qw1}
 \end{equation}
 
Здесь $∆_{h} $ -- стандартный разностный оператор Лапласа; $D_{h}$ -- сеточная область (множество внутренних узлов); $Γ_{h}$  сеточная граница; $u^{h}$ --  сеточная функция, определенная на $D_{h} \cup \Gamma_{h}$ ;$g^{h},c^{h},M^{h},\phi^{h}$ -- значения соответствующих функций в узлах сетки. Для простоты изложения здесь
рассматривается вариант, когда все граничные узлы сетки лежат на исходной границе $Γ$, то есть область $D_{h}$ является объединением "координатных" параллелепипедов.

Свойства разностной аппроксимации оператора Лапласа позволяют
предположить, что при достаточно малых $h$ все собственные значения
оператора $∆_{h}$ для области $D_{h}$ отрицательны. Обозначим через -- $c^{*}_{h}$ то из них, которое имеет наименьшую абсолютную величину. Тогда для $ M^{h}+\lambda_{0} < c^{*}_{h} $
задача имеет единственное решение.

Уравнение \ref{qw1} можно представить в виде:
\begin{equation}
u^{h}_{i}=s_{i}\sum^{L}_{j=1}{p_{ij}u^{h}_{j}+f^{h}_{i}},
	\label{qw2}
\end{equation} 
где $i; j = (1; \dots; L)$ --  номера узлов сетки, причем $p_{ij} = 1/(2n)$, если i 
номер внутреннего узла, а j  соседнего с ним; $p_{ij} = 0$ для граничных
узлов. Для граничных узлов полагаем $s_{i} = 0$; для остальных узлов
\begin{equation}
s_{i}= 
	\left[
1-\frac{(c^{h}_{i}+\lambda)h^{2}}{2n}
 \right]^{-1}
	\label{qw3}.
\end{equation}
Свободный элемент $f^{h}$ определяется соотношениями:
\begin{equation} f^{h}_{i}= 
	\left\{
\begin{aligned}
& \frac{h^{2}}{2n}s_{i}g^{h}_{i}, r_{i} \in D_{h}\\ & \phi^{h}_{i}, r_{i} \in \Gamma_{h}
\end{aligned}
 \right. 
 \label{qw4}
 \end{equation}
\subsection{Оценка решения уравнения $(∆ + c)(∆ + b)u = -g$}
Рассмотрим следующую задачу Дирихле для бигармонического уравнения: 
\begin{equation} 
	\left\{
\begin{aligned}
& (∆ + c)(∆ + b)u = -g,\\ & \Delta u + bu|_{\Gamma} = \phi, \\ & u|_{\Gamma} = \psi, 
\end{aligned}
 \right. ,\label{qw5}\end{equation}
и эквивалентную ей систему уравнений
\begin{equation} 
	\left\{
\begin{aligned}
&\Delta u + bu =\upsilon, \\ & u|_{\Gamma} = \psi, \\  &\Delta \upsilon + c\upsilon =-g,
\\  & \upsilon|_{\Gamma} = \phi
\end{aligned}
 \right.  \label{qw6}
\end{equation}
в области $D\in R^{n}$ с границей $\Gamma$, которая предполагается односвязной и
кусочно гладкой, причем 
\begin{equation}
	M=\max{[Re(b),Re(c)]} < c^{*},
\end{equation}
где $c^{*}$ первое собственное значение оператора Лапласа для области $D$, произвольная точка $ r = (x_{1}; \dots; x_{n}) \in D$. Будем полагать также что функции $c, b, и g $ удовлетворяют условию Гельдера в $D$ , а функции $ \psi, \phi$ непрерывны на границе Г. Условия регулярности, обеспечивающие существование и единственность решения данной задачи, предполагаются выполненными в том числе и после замены всех параметрических функций их модулями.

В области D строится равномерная сетка с шагом h и в качеств
оценки решения исходной задачи в узлах сетки $r = (i_{1}h; \dots ; i_{n}h)$ рассматривается решение разностной задачи:

\begin{equation} 
	\left\{
\begin{aligned}
&\Delta_{h} u^{h} + b^{h}u^{h} =\upsilon^{h}, \\
&u^{h}|_{\Gamma_{h}} = \psi^{h}
\end{aligned}
 \right. ,\label{qw8}
\end{equation}

\begin{equation} 
	\left\{
\begin{aligned}
&\Delta_{h} \upsilon^{h} + c^{h}\upsilon^{h} =-g^{h},\\  & \upsilon^{h}|_{\Gamma_{h}} = \phi^{h}
\end{aligned}
 \right. ,\label{qw9}
\end{equation}
где $\upsilon^{h}$ -- сеточная функция, определенная на $D^{h} \cup \Gamma_{h}; b^{h}, \psi^{h}$ --  значения функций $b(r), \psi(r)$ в узлах сетки. Остальные обозначения и условия
примем такими же как в \ref{Bl}. Тогда для $M^{h} < c^{*}_{h}$  задача \ref{qw8} и \ref{qw9}
имеет единственное решение.
Соотношения \ref{qw8}, \ref{qw9} перепишем в виде:
\begin{equation}
	\upsilon^{h}_{i}=q_{i}\sum^{L}_{j=1}{p_{ij}\upsilon^{h}_{j}}+f^{h}_{i},
\end{equation}
\begin{equation}
	u^{h}_{i}=q_{i}\sum^{L}_{j=1}{p_{ij}u^{h}_{j}}+f^{h}_{i},
\end{equation}
где $i,j=(1,\dots,L)$ --  номера узлов сетки, причем $p_{ij}=1/(2n)$, если и 
номер внутреннего узла, а $j$ --  соседнего с ним; $p_{ij}= 0$ для граничных
узлов. Для граничных узлов полагаем $q_{i}=s_{i}=0$; для остальных узлов
\begin{equation}
	q_{i}=[1-c^{h}_{i}h^{2}/(2n)]^{-1} ,\\ s_{i}=[1-b^{h}_{i}h^{2}/(2n)]^{-1}.
\end{equation}
Свободные элементы $f_{h}$ и 
$\bar{f}_{h}$ определяются соотношениями:
\begin{equation}
	f^{h}_{i}= 
	\left\{
\begin{aligned}
& \frac{h^{2}}{2n}q_{i}g^{h}_{i}, r_{i} \in D_{h}\\ & \phi^{h}_{i}, r_{i} \in \Gamma_{h}
\end{aligned}
 \right. ,\\
\bar{f}^{h}_{i}= 
	\left\{
\begin{aligned}
& -\frac{h^{2}}{2n}s_{i}\upsilon^{h}_{i}, r_{i} \in D_{h}\\ & \psi^{h}_{i}, r_{i} \in \Gamma_{h}
\end{aligned}
 \right. .
\end{equation}
Согласно теореме 5 из \cite{luk:dis}:
\begin{equation}
	\xi_{i_{0}}=\frac{-h^{2}}{2n}\sum^{N}_{j=0}{f^{h}_{i_{j}}}\sum^{j}_{l=0}{(\prod^{l}_{k=0}{s_{i_{k}}})(\prod^{j-1}_{k=l}{q_{i_{k}}})+(\prod^{N-1}_{k=0}{s_{i_{k}}})\psi^{h}_{i_{N}}}\\
	\prod^{j-1}_{k=j}=\left\{
\begin{aligned}
& 1, j<N\\ & 0, j=N
\end{aligned}
 \right. .
\end{equation}

Здесь $i_{0},\dots,i_{n}$ -- номера узлов случайной цепи Маркова с начальным
распределением $\delta_{i_{0}} $ и вероятностями перехода $p_{ij}$ , $N$ -- случайный номер
первого попадания на границу сеточной области.
\section{Блуждание по сферам}
Рассмотрим задачу Дирихле для уравнения Гельмгольца
\begin{equation} \Delta u + cu = g,	 u|_{\Gamma} = \phi \end{equation}
в области $D \subset R^{n}$ с границей $\Gamma$ , причем $c < c^{*}$, где $c^{*}$ первое собственное число оператора Лапласа для области $D, r = (x1;\dots; xn) \in D$. Предполагаются выполненными сформулированные условия регулярности функций g, ' и границы $\Gamma$, обеспечивающие существование и единственность решения задачи , а также его вероятностное представление и интегральное представление с помощью шаровой функции Грина.

Введем следующие обозначения:
\begin{itemize}
	\item $\bar{D}$  -- замыкание области $D$;
	\item $d(P)$ -- расстояние от точки $P$ до границы $\Gamma$;
	\item $\epsilon > 0 $ -- числовой параметр;
	\item $\Gamma_{\epsilon }$ -- $\epsilon$ -- окрестность границы $\Gamma$, т. е. $ \Gamma_{\epsilon }=\{ P \in \bar{D}:d(P) < \epsilon \} $;
	\item $S(P)$  максимальная из сфер (точнее - из гиперсфер) с центром в точке $P$, целиком лежащих в $\bar{D}, S(P) = \{Q \in \bar{D}: |Q - P| = d(P)\}$.
\end{itemize}

В процессе блуждания по сферам очередная точка $P_{k+1}$ выбирается равномерно по поверхности сферы $S(P_{k})$; процесс обрывается, если точка попадает в $ \Gamma_{\epsilon }$. Дадим точное определение процесса блуждания по сферам. Зададим цепь Маркова $\{R_{m}\}_{m=1,2,\dots,N} $ следующими характеристиками:\begin{itemize}
	\item $\pi (r) = \delta(r-r_{0})$ - плотность начального распределения (т.е. цепь выходит из точки $r_0$);
	\item $p(r,r') = \delta_{r}(r') $ плотность перехода из $r$ в $r'$, представляющая собой обобщенную плотность равномерного распределения вероятностей на сфере $S(r)$;
	\item $p_{0}(r)$ вероятность обрыва цепи, определяемая выражением \begin{equation} p_{0}(r)= 
	\left\{
\begin{aligned}
& 0, r \notin \Gamma_{\epsilon}\\ & 1, r\notin \Gamma_{\epsilon}
\end{aligned};
 \right. \end{equation}
\item{}$N$ - номер последнего состояния.
\end{itemize}
Как уже указывалось, данная цепь называется процессом блуждания по сферам. Ее можно, очевидно, записать в виде $r_{m} = r_{m-1} + \omega_{m}d(r_{m-1}); m = 1; 2;....;$
$\omega_{m}$ -- последовательность независимых изотропных векторов единичной
 длины.
\subsection{Оценки решения метагармонического уравнения$(\delta+c)^{p}u=g $}
Для случая $L=\delta, \lambda=0,c = const<c*$ вероятностное представление задачи имеет вид 
\begin{equation} u(r_{0})=E\int_{0}^{\gamma}e^{ct}g(\xi(t))dt+E[e^{c\tau}\Phi(\xi(\tau))],\end{equation}
где $\xi(t)$  начинающийся в точке $r_{0}$ соответствующий оператору Лапласа диффузионный процесс, $\tau $  момент первого выхода процесса из области D. На основе строго марковского свойства процесса отсюда имеем 
\begin{equation} u(r_{0})=\sum_{i=0}^{\infty} E [e^{c\tau_{i}} \int_{0}^{\tau_{i+1}-\tau_{i}}e^{ct}g(\xi(t+\tau_{i}))dt+E[\Phi(\xi(\tau)){}
\prod_{i=0}^{\infty}e^{c(\tau_{i+1}-\tau_{i})}],\end{equation}
где $ \tau_{i}$ - момент первого выхода процесса $\xi(t)$ на поверхность $i$-й сферы соответствующего блуждание по сферам.
\section{Алгоритмы распределения траекторий}
В библиотеке используется два алгоритма распределения траекторий: статический (равное распределение задачи при равных вычислительных узлах) и динамический (предполагает разные вычислительные мощности отдельных узлов).

Статический метод распределяет траектории в равных долях плюс процесс для не нулевого и вычет общего числа процессов на нулевом. Это связано с общим суммированием результата на нулевом процессе.

Динамический распределяет половину траекторий в равных долях между не нулевыми процессами(в дальнейшем -- вычислители). Нулевой процесс выполняет роль менеджера распределения траекторий (МРТ). При окончании расчетов первым вычислителем МПТ получает коэффициент производительности (КП) выраженный в секундах на проход. Этой величине присваивается единичный статус и назад отправляется количество проходов равное первоначальным условиям, но от оставшегося числа. Если остается меньше необходимого минимума он отправляется полностью, а МРТ переходит к сбору данных. При приходе последующих КП они сравниваются с единичным. Если он меньше, то текущей становится единичным. Назад отправляем \begin{equation} nWay = \frac{N}{2aP\frac{Kp_{i}}{Kp_{1}}}, \end{equation} где Кр - коэффициент производительности, $size$ - общие количество процессов, $aP=size-1$. Если $nWay$ меньше необходимого минимума отправляется $N$ полностью, а МРЗ переходит к сбору данных. В графическом представлении алгоритм можно просмотреть на рисунке \ref{staticAndDinamic}

\begin{figure}
\begin{small}
\input{staticAndDinamic}
\end{small}
\caption{Динамический алгоритм}
\label{staticAndDinamic}
\end{figure}

\chapter{Выполнение задачи}
\section{Используемые программные средства}
При создании требуемой библиотеки были использованы следующие программные средства и технологии.   

Message Passing Interface (MPI, интерфейс передачи сообщений) -- программный интерфейс (API)\footnote{Application programming interface} для передачи информации, который позволяет обмениваться сообщениями между процессами, выполняющими одну задачу. Разработан Уильямом Гроуппом, Эвином Ласком и другими.

MPI является наиболее распространённым стандартом интерфейса обмена данными в параллельном программировании. Существуют его реализации для большого числа компьютерных платформ. MPI используется при разработке программ для кластеров и суперкомпьютеров. Основным средством коммуникации между процессами в MPI является передача сообщений друг другу. Стандартизацией MPI занимается MPI Forum. В стандарте MPI описан интерфейс передачи сообщений, который должен поддерживаться как на платформе, так и в приложениях пользователя. В настоящее время существует большое количество бесплатных и коммерческих реализаций MPI. Существуют реализации для языков Фортран 77/90, Java, Си и Си++.

В первую очередь MPI ориентирован на системы с распределенной памятью, то есть когда затраты на передачу данных велики, в то время как OpenMP\footnote{http://openmp.org/wp/} ориентирован на системы с общей памятью (многоядерные с общим кэшем). Обе технологии могут использоваться совместно, дабы оптимально использовать в кластере многоядерные системы. Более подробно об этом \cite{mpi:offsite}.

При разработке прикладного кода использовалась распределённая система управления версиями файлов -- Git

Git — распределённая система управления версиями файлов. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день поддерживается Джунио Хамано.

Система управления версиями (от англ. Version Control System, VCS или Revision Control System) -- программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое.

Такие системы наиболее широко используются при разработке программного обеспечения для хранения исходных кодов разрабатываемой программы. Однако они могут с успехом применяться и в других областях, в которых ведётся работа с большим количеством непрерывно изменяющихся электронных документов. В частности, системы управления версиями применяются в САПР, обычно в составе систем управления данными об изделии (PDM). Управление версиями используется в инструментах конфигурационного управления (Software Configuration Management Tools).
Программа является свободной и выпущена под лицензией GNU GPL 2.

Язык для написания приложения был выбран С++ как наиболее подходящий для разработки статической библиотеки.

Статическая библиотека в программировании -- сборник подпрограмм или объектов, используемых для разработки программного обеспечения (ПО) выполненных в виде исходного текста, подключаемого программистом к своей программе на этапе написания, либо в виде объектных файлов, подключающихся к исполняемой программе на этапе компиляции. В результате программа включает в себя все необходимые функции, что делает её автономной, но увеличивает размер. Без статических библиотек объектных модулей (файлов) невозможно использование большинства современных компилирующих языков и систем программирования: Fortran, Pascal, C, C++ и других.

Статическая библиотека присоединяется во время компиляции программы в то время как присоединение динамической происходит во время выполнения.

\chapter{Итоги работы}
Результатом выполнения дипломного проекта стало разработка и реализация алгоритмов распределения траекторий, реализация методов численного решения бигармонического уравнения. Это было вынесено в отдельный класс, на основании которого была создана статическая библиотека.  
\section{Структура библиотеки}
Библиотека содержит главный класс POINT\_ON\_RESHOTKA.
Который содержит следующие открытые методы: SetU, setG, setPhi, SetBoundary, РrintDebag и printResult, Init, MainRun, SetFlag.
SetU,setG,setPhi -- задают соответствующие функциональные параметры.
SetBoundary -- функция определения границы.
РrintDebag и printResult -- печать результатов (данные для анализа алгоритма и результат вычислений соответственно).
Init -- инициализация библиотеки MPI и класса.
MainRun -- запуск вычислений.
SetFlag -- установка флагов.

Закрытыми методами являются: voidSphere, diam, staticSphere, dinamicSphere.
VoidSphere -- проход по траекториям.
StaticSphere -- реализация статичного алгоритма распределения траекторий.
DinamicSphere -- реализация динамического алгоритма распределения траекторий.

Описание класса и функций содержатся в приложении.
\section{Численные результаты}
Рассмотрим численные результаты для следующий задачи Дихиле:
\begin{equation} 
	\left\{
\begin{aligned}
& (\Delta + 2) (\Delta +8) u = 40e^{x}e^{y}\\ & (\Delta +8) u|_{\Gamma} = 10e^{x}e^{y}\\&u|_{\Gamma} = e^{x}e^{y}
\end{aligned}
 \right. \end{equation}
{}
в единичном квадрате. Решение данной задачи дано в \cite{luk:dis}.

\begin{table}
	\caption{Время выполнения и расхождения}
	\label{sample_table}
\begin{tabular}{|c|c|c|c|c|}
\hline 
Metot & N & Кол.& $t_{cp}$ & $\Delta$ проходов \\ \hline
Par1 & 100003 & 4 & 0.6 sec & $+/- 200 $ \\ \hline
Par1 & 1000030 & 4& 6 sec & $+/- 250 $ \\ \hline
Par2 & 100003 & 4 &1 sec & $+/- 10 $ \\ \hline
Par2 & 1000030 & 4 & 12 sec & $+/- 10 $ \\ \hline
Par2 & 1000030 & 5 & 8 sec & $+/- 10 $ \\ \hline
Pos & 100003 & 1 &2 sec & -- \\ \hline
Pos & 1000030 & 1 &25 sec & -- \\ \hline
\end{tabular}
\end{table}

В таблице \ref{sample_table} представлены результаты производительности, оценки точности и численные результаты совпадают для всех методов. Используются следующие сокращения для таблицы: Por - результаты получены в аналоге, Par1 - статичный метод расчета, Par2 - динамичный метод расчета. Измерения проводились на однопроцессорной машине.

Как видим статический алгоритм обеспечил лучшую производительность на однопроцессорной машине.
\chapter{Руководство пользователя}
\section{Установка}
Для сборки приложения под Windows необходимо MPICH2, набор утилит для компиляции: компилятор GNU GCC и GNU Make данные утилиты представлены в пакете MinGW. Для Linux GNU GCC не обязателен, компиляция происходит силами пакета MPICH2.
\begin{enumerate}
	\item Скачайте необходимую версию библиотеки с тестовым примером.
	\item Запустите консоль в папке проекта или перейдите в нее с помощью команды cd.
	\begin{itemize}
		\item нажмите Пуск -> Выполнить -> cmd - Это откроет консоль Windows;
		\item в консоли наберите имя диска на котором располагается проект с двоеточием на конце (C:);
		\item там же напечатайте cd <путь к проекту > (cd C:\\project).
	\end{itemize}
	\item Запустите make.
\end{enumerate}
Результатом станет скомпилированный тестовый пример и статическая библиотека находящиеся в папке с проектом.

\section{Запуск приложения}
Для запуска приложения набрать в консоли:\\
linux\\
	mpirun -n <Кол. процессов> <Имя программы> [опции]\\
windows\\
	mpiexec -n <Кол. процессов> <Имя программы> [опции]\\
Опции\\
-n<Кол.Путей> - Задает количество путей\\
-l  - Печать заголовка таблицы\\
-f - Печать в общем виде (иначе табличный)\\
\\
Пример:\\
	mpirun -n 100 ./main -n3000 -l\\
\newpage\likechapter{Заключение}
 Сформируем основные результаты работы:
 \begin{enumerate}
	\item Изучена новая предметная область. 
	\item Найдены и рассмотрены существующие аналоги.
	\item Составлена список требований к системе.
	\item Исследованы методы Монте-Карло.
	\item Исследованы способы два алгоритма реализации распределения задачи.
	\item Разработан пользовательский интерфейс.
	\item Реализованы два алгоритма распределения задач для двух методов вычислений. 
	\item Сделано анализ времени выполнения алгоритмов распределения траекторий с различным количеством потоков в сравнение с последовательным аналогом.
\end{enumerate}
